# 密码锁
## LCD1602液晶屏说明
### LCD1602引脚及其功能
<img width="903" height="622" alt="屏幕截图 2026-02-24 133146" src="https://github.com/user-attachments/assets/d812e0c8-3fc1-475c-8461-28124090eac7" />
<img width="754" height="394" alt="屏幕截图 2026-02-24 133931" src="https://github.com/user-attachments/assets/f067e180-fb4f-4cc3-b0e5-2c66a5307273" />

### LCD1602的RAM地址
- LCD1602总共显示为16行2列，对应32个RAM地址使用时需要在那个位置显示就写入对应的RAM地址
<img width="722" height="247" alt="屏幕截图 2026-02-24 134211" src="https://github.com/user-attachments/assets/b1a6968d-f001-4454-93df-514a0169ae23" />

### LCD1602的读写时序
- 在写之前先实现一个LCD的延时函数，大约延时半毫秒：
```c
void LCD_Delay()
{
	unsigned char i, j;

	i = 2;
	j = 239;
	do
	{
		while (--j);
	} while (--i);
}
```


- 写时序
- <img width="646" height="301" alt="image" src="https://github.com/user-attachments/assets/bd3b2fbd-1215-450e-8383-f7ecfb1817d3" />
-根据写时序封装相应代码 ：
- 写入控制字
```c
void LCD_WriteCommand(unsigned char Command)
{
	LCD_RS=0;
	LCD_RW=0;
	LCD_DataPort=Command;
	LCD_EN=1;
	LCD_Delay();
	LCD_EN=0;
	LCD_Delay();
}
//写入数据之后要延时一段时间让LCD1602有充分时间读入
```
- 写入数据
```c
void LCD_WriteData(unsigned char Data)
{
	LCD_RS=1;
	LCD_RW=0;
	LCD_DataPort=Data;
	LCD_EN=1;
	LCD_Delay();
	LCD_EN=0;
	LCD_Delay();
}
```
-光标设置（也就是在哪里写入并且显示，对应其RAM地址）
```c
void LCD_SetCursor(unsigned char Line,unsigned char Column)
{
	if(Line==1)
	{
		LCD_WriteCommand(0x80|(Column-1));        
	}
	else if(Line==2)
	{
		LCD_WriteCommand(0x80|(Column-1+0x40));  //DDRAM 地址空间分为多个段，0x00~0x27 分配给第一行，0x40~0x67 分配给第二行
	}
}
```
- 0x80:
- 1000 0000 最高位D7位为1触发 “设置DDRAM地址”

- 接下来的代码就是对LCD1602的初始化，以及对各种类型的字符的显示
 逻辑大致相似，先是设置对应光标值(也就是在哪里写入)，对应相应的ASCII码写入对应的数据，写入方式因数据类型而异
 本次重点在于数据的读写封装


- 读时序
- <img width="638" height="274" alt="image" src="https://github.com/user-attachments/assets/3c402a00-8183-46b9-b046-e9ba221e28da" />
- 由于次并无对读有需求，所以暂且不实现读时序

## 矩阵键盘模块
- 按键抖动特性
<img width="769" height="341" alt="image" src="https://github.com/user-attachments/assets/f12cd4eb-a78b-4cc5-96b2-f60b4668efac" />

- 由于按键的抖动特点，我们要做出对应的消抖处理（延时一定的时间）<br>实现如下（这里只给出一个例子）
- ```c
  Delay(20);while(P1_7==0);Delay(20);KeyNumber=1;
  ```
解释一下一开始按键按下转为低电平由于抖动，我们先对其进行延时20ms处理<br>
while（P1_7==0）;则是检测按键松开如果松开则转为高电平循环打破，由于抖动我们还是要给他进行消抖<br>
完事之后我们再对相应的KeyNum赋相应的按键值，给后续编写

- 根据开发板的原理图 矩阵键盘模块对应端口，我们就可以写出对应驱动模块
- ```c
  unsigned char MatrixKey()
{
	unsigned char KeyNumber=0;
	P1=0xFF;   //「初始化 / 复位」P1 口状态，避免上一次扫描的电平残留影响本次检测
	P1_3=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=1;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=5;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=9;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=13;}
	
	P1=0xFF;
	P1_2=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=2;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=6;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=10;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=14;}
	
	P1=0xff;
	P1_1=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=3;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=7;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=11;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=15;}
	
	P1=0xff;
	P1_0=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=4;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=8;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=12;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=16;}
	return KeyNumber;
} ```

## 主函数模块
- 在主函数中实现密码输入Password 并存储于Password变量中
- Count变量用于实现统计密码的位数
- 定义了一个变量KeyNum来接受键盘扫描的键码
- 这里设置KeyNum==11时为确定键，则检测密码是否正确模块
- 这里设置KeyNum==12时为清0，清0的逻辑很简单直接设置Password的值为0即可 Count的值为0
- 当KeyNum<11时则为输入数字操作,如下实现了输入后移的操作
```c
Password*=10;
Password+=KeyNum%10;
Count++;
```


